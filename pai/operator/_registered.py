import six

from pai.common.yaml_utils import safe_load as yaml_safe_load, dump as yaml_dump
from pai.core import Session
from pai.operator._base import OperatorBase, UnRegisteredOperator
from pai.operator.types.spec import load_input_output_spec


class SavedOperator(OperatorBase):
    """SavedOperator represent the pipeline schema from pipeline/component.

    SavedOperator object include the definition of "Workflow" use in PAI pipeline service.
     It could be fetch from remote pipeline service or construct from local Pipeline/Component.
     Saved pipeline operator has unique `pipeline_id` which is generated by pipeline service.

    """

    def __init__(self, pipeline_id, manifest=None, workspace_id=None):
        """Template constructor.

        Args:
            manifest: "Workflow" definition of the pipeline.
            pipeline_id: Unique ID for pipeline in PAI service.
            workspace_id: ID of the workspace which the pipeline belongs to.
        """
        if not manifest:
            session = Session.current()
            manifest = session.get_pipeline_by_id(pipeline_id)["Manifest"]
        if isinstance(manifest, six.string_types):
            manifest = yaml_safe_load(manifest)

        self._manifest = manifest
        self._pipeline_id = pipeline_id
        self._workspace_id = workspace_id

        inputs, outputs = load_input_output_spec(self, manifest["spec"])

        self._identifier = manifest["metadata"]["identifier"]
        self._provider = manifest["metadata"]["provider"]
        self._version = manifest["metadata"]["version"]
        super(SavedOperator, self).__init__(
            inputs=inputs,
            outputs=outputs,
        )

    def __repr__(self):
        return "%s:Id=%s,Identifier=%s,Provider=%s,Version=%s" % (
            type(self).__name__,
            self._pipeline_id,
            self.identifier,
            self.provider,
            self.version,
        )

    def __eq__(self, other):
        return isinstance(other, type(self)) and other.pipeline_id == self.pipeline_id

    @property
    def identifier(self):
        return self._identifier

    @property
    def provider(self):
        return self._provider

    @property
    def version(self):
        return self._version

    @property
    def pipeline_id(self):
        """Unique ID of the pipeline in PAI pipeline service.

        Returns:
            str: Unique pipeline ID of the operator instance.

        """
        return self._pipeline_id

    @property
    def manifest(self):
        """Pipeline manifest schema.

        Returns:
            dict: Pipeline manifest schema in dict.
        """
        return self._manifest

    @property
    def raw_manifest(self):
        """Pipeline manifest in YAML format

        Returns:
            str: Pipeline manifest.
        """
        return yaml_dump(self._manifest)

    # @property
    # def workspace(self):
    #     """Workspace of the pipeline operator
    #
    #     Pipeline operator belongs to a specific workspace in PAI service. Workspace property reveal
    #      the workspace which the saved pipeline operator belongs to.
    #
    #     Returns:
    #         pai.core.workspace.Workspace: Workspace of the saved pipeline operator.
    #
    #     """
    #     return Workspace.get(self._workspace_id) if self._workspace_id else None
    #
    @classmethod
    def get_by_identifier(cls, identifier, provider=None, version="v1"):
        """Get SavedOperator with identifier-provider-version tuple.

        Args:
            identifier (str): Pipeline identifier.
            provider (str): Provider of the Pipeline, account uid of the current session will be used as
              default.
            version (str): Version of the pipeline.

        Returns:
            pai.pipeline.SavedOperator: SavedOperator instance

        """

        if not provider:
            sess = Session.current()
            provider = sess.provider

        session = Session.current()
        pipeline_info = session.get_pipeline(
            identifier=identifier, provider=provider, version=version
        )
        if not pipeline_info:
            raise ValueError(
                "Not found pipeline with specific information: identifier={0}, provider={1}, version={2}".format(
                    identifier, provider, version
                )
            )

        return cls(
            manifest=pipeline_info["Manifest"],
            pipeline_id=pipeline_info["PipelineId"],
        )

    @classmethod
    def list(cls, identifier=None, provider=None, version=None, workspace_id=None):
        """List the SavedOperator in PAI

        Search the pipeline operator available in remote PAI service. The method return a
        generator used to traverse the SavedOperator set match the query condition.

        Args:
            identifier (str): Pipeline identifier filter.
            provider (str): Pipeline provider filter.
            version (str): Pipeline version.
            workspace_id (str): Workspace id of the pipeline.

        Yields:
              pai.operator.SavedOperator: SavedOperator match the query.
        """

        if not provider:
            sess = Session.current()
            provider = sess.provider if sess else None

        pl_gen = cls._get_service_client().list_pipeline_generator(
            identifier=identifier,
            provider=provider,
            version=version,
            workspace_id=workspace_id,
        )

        for info in pl_gen:
            yield cls.deserialize(info)

    def update(self, op):
        """Update current registered operator/pipeline using the manifest of given operator/pipeline.

        Args:
            op (Union[UnRegisteredOperator, str, dict]): New pipeline/operator spec,
            could by a unregistered operator, dict or yaml in str.
        """
        client = Session.current().paiflow_client
        if isinstance(op, UnRegisteredOperator):
            manifest = op.to_manifest(identifier=self.identifier, version=self.version)
        elif isinstance(op, str):
            manifest = op
        elif isinstance(op, dict):
            manifest = yaml_dump(op)

        else:
            raise ValueError(
                "Please provider ContainerOperator, Pipeline or Manifest in string to update the registered operator."
            )
        client.update_pipeline(self._pipeline_id, manifest)

    def delete(self):
        """Delete this registered operator/pipeline."""
        client = Session.current().paiflow_client
        client.delete_pipeline(self.pipeline_id)

    @classmethod
    def deserialize(cls, obj_dict):
        manifest, id, workspace_id = (
            obj_dict.get("Manifest"),
            obj_dict["PipelineId"],
            obj_dict.get("WorkspaceId", None),
        )
        return cls(
            workspace_id=workspace_id,
            pipeline_id=id,
            manifest=manifest,
        )

    @classmethod
    def _has_impl(cls, manifest):
        if isinstance(manifest, six.string_types):
            manifest = yaml_safe_load(manifest)

        if "spec" not in manifest:
            return False
        spec = manifest["spec"]
        if "pipelines" not in spec and "container" not in spec:
            return False
        return True

    @classmethod
    def get(cls, pipeline_id):
        """Get SavedOperator with pipeline_id.

        Args:
            pipeline_id (str): Unique pipeline id.

        Returns:
            pai.pipeline.SavedOperator: SavedOperator instance with the
             specific pipeline_id

        """
        client = cls._get_service_client()
        pipeline_info = client.get_pipeline_schema(pipeline_id=pipeline_id)
        return cls.deserialize(pipeline_info)

    def save(self, identifier=None, version=None):
        raise NotImplementedError("SaveTemplate is not savable.")

    def _submit(self, job_name, args):
        session = Session.current()
        run_id = session.create_run(
            job_name,
            args,
            no_confirm_required=True,
            pipeline_id=self._pipeline_id,
            workspace=session.workspace,
        )
        return run_id

    def io_spec_to_dict(self):
        return {
            "inputs": self.inputs.to_dict(),
            "outputs": self.outputs.to_dict(),
        }
